//
//  ToModelExtensions.swift
//  GigaCmt
//
//  Created by dlwpdlr on 2018/9/8.
//  Copyright © 2018年 GIGA Korea. All rights reserved.
//

import Foundation
import RxSwift
import Moya
import HandyJSON
import ObjectMapper

extension ObservableType where E == Response {
	public func mapModel<T: HandyJSON>(_ type: T.Type) -> Observable<T> {
		return flatMap { response -> Observable<T> in
			return Observable.just(response.mapModel(T.self))
		}
	}
}

extension Response {
	func mapModel<T: HandyJSON>(_ type: T.Type) -> T {
		let jsonString = String.init(data: data, encoding: .utf8)
		return JSONDeserializer<T>.deserializeFrom(json: jsonString)!
	}
}


extension Observable {
	func mapObject<T: Mappable>(type: T.Type) -> Observable<T> {
		return self.map { response in
			//if response is a dictionary, then use ObjectMapper to map the dictionary
			//if not throw an error
			guard let dict = response as? [String: Any] else {
				throw RxSwiftMoyaError.ParseJSONError
			}
			
			return Mapper<T>().map(JSON: dict)!
		}
	}
	
	func mapArray<T: Mappable>(type: T.Type) -> Observable<[T]> {
		return self.map { response in
			//if response is an array of dictionaries, then use ObjectMapper to map the dictionary
			//if not, throw an error
			guard let array = response as? [Any] else {
				throw RxSwiftMoyaError.ParseJSONError
			}
			
			guard let dicts = array as? [[String: Any]] else {
				throw RxSwiftMoyaError.ParseJSONError
			}
			
			return Mapper<T>().mapArray(JSONArray: dicts)
		}
	}
}

enum RxSwiftMoyaError: String {
	case ParseJSONError
	case OtherError
}

extension RxSwiftMoyaError: Swift.Error { }
